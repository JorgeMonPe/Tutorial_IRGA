[["index.html", "Un tutorial para calcular el flujo de CO2 a partir de un archivo del IRGA Sobre el tutorial 0.1 Estructura del tutorial", " Un tutorial para calcular el flujo de CO2 a partir de un archivo del IRGA Jorge Juan Montes Pérez 2023-04-12 Sobre el tutorial Esto es un tutorial para facilitar el tratatimendo de datos de los archivos obtenidos con el IRGA EGM-5 usando R y RStudio. 0.1 Estructura del tutorial Este documento está editado con bookdown. Lo podéis leer directamente en html (recomendado) o descargarlo tanto en formato pdf como en formato mobi. En la parte superior, encontraréis un icono para desplegar u ocultar la tabla de contenidos, un icono para buscar dentro del documento,un icono para descargar los formatos pdf y mobi y varios icono para compartir a través de distintas plataformas. A lo largo del documento entraréis “trocitos” de código R. Si pincháis en el recuadro code se desplegará todo el código y os aparecerá un icono para copiarlo. De esta manera, podréis ir copiando el código a vuestro script de R e ir siguiendo cada paso de la práctica. Tutorial para calcular tasas de emisión by Jorge Juan Montes Pérez is licensed under a Creative Commons Reconocimiento-NoComercial 4.0 Internacional License. "],["introducción.html", "Introducción 0.2 ¿Porqué un analiador de gases infrarrojos? 0.3 ¿Porqué medir las emisiones o la absorción de CO2?", " Introducción Si has llegado a este tutorial, posiblemente ya tengas claro para que vas a medir las emisiones o la absorción de CO2 con un analizador de gases infrarrojos (IRGA). Sin embargo, …. 0.2 ¿Porqué un analiador de gases infrarrojos? En construcción… 0.3 ¿Porqué medir las emisiones o la absorción de CO2? En construcción… "],["importar-el-archivo-.html", "1 Importar el archivo “*.TXT”", " 1 Importar el archivo “*.TXT” ¡Vamos a remangarnos! Lo primero que tenemos que hacer es importar el archivo *.TXT que nos genera el IRGA. En el manual del analizador podéis encontrar la información relativa a cada una de las columnas que aparecen en el archivo. Pódeis probar con vuestro propio archivo o descargar este que os dejo de prueba pincha aquí. library(tidyverse) library(lubridate) #Open IRGA text files Data_file &lt;- read_csv(&#39;./IRGA_files/23031311.TXT&#39;, skip = 2, col_names = FALSE, comment = &#39;Start&#39;) Vamos a ver que es lo que hemos importado: str(Data_file) ## spec_tbl_df [3,430 × 22] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ X1 : chr [1:3430] &quot;M5&quot; &quot;M5&quot; &quot;M5&quot; &quot;M5&quot; ... ## $ X2 : chr [1:3430] &quot;13/03/23&quot; &quot;13/03/23&quot; &quot;13/03/23&quot; &quot;13/03/23&quot; ... ## $ X3 : &#39;hms&#39; num [1:3430] 15:52:22 15:52:23 15:52:24 15:52:25 ... ## ..- attr(*, &quot;units&quot;)= chr &quot;secs&quot; ## $ X4 : num [1:3430] 1 1 1 1 1 1 1 1 1 1 ... ## $ X5 : num [1:3430] 553 554 555 556 557 558 559 560 561 562 ... ## $ X6 : num [1:3430] 416 416 417 417 417 418 418 419 419 419 ... ## $ X7 : num [1:3430] 1000 1000 1000 1000 1000 ... ## $ X8 : num [1:3430] 342 343 344 343 343 343 343 343 344 344 ... ## $ X9 : num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X10: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X11: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X12: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X13: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X14: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X15: num [1:3430] 31.7 31.7 31.7 31.7 31.7 31.7 31.7 31.7 31.7 31.7 ... ## $ X16: num [1:3430] 36.9 36.9 36.8 36.8 36.8 36.8 36.7 36.7 36.7 36.7 ... ## $ X17: num [1:3430] 24.4 24.4 24.4 24.4 24.4 24.4 24.4 25.4 25.4 25.4 ... ## $ X18: num [1:3430] 20 20 20 20 20 20 20 20 20 25 ... ## $ X19: num [1:3430] 0 0 0 1 1 2 2 2 2 2 ... ## $ X20: num [1:3430] 1 2 3 4 5 6 7 8 9 10 ... ## $ X21: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## $ X22: num [1:3430] 0 0 0 0 0 0 0 0 0 0 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. X1 = col_character(), ## .. X2 = col_character(), ## .. X3 = col_time(format = &quot;&quot;), ## .. X4 = col_double(), ## .. X5 = col_double(), ## .. X6 = col_double(), ## .. X7 = col_double(), ## .. X8 = col_double(), ## .. X9 = col_double(), ## .. X10 = col_double(), ## .. X11 = col_double(), ## .. X12 = col_double(), ## .. X13 = col_double(), ## .. X14 = col_double(), ## .. X15 = col_double(), ## .. X16 = col_double(), ## .. X17 = col_double(), ## .. X18 = col_double(), ## .. X19 = col_double(), ## .. X20 = col_double(), ## .. X21 = col_double(), ## .. X22 = col_double() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; Ahora vamos a arreglar un poco el el data.frame para que sea más fácil como trabajar con él. #Remove rows with &quot;End&quot; Data_file &lt;- Data_file %&gt;% filter(X1 != &quot;End&quot; | X1 != &quot;Zero&quot;) #Select just rows with M5 Data_file &lt;- Data_file %&gt;% filter(X1 == &quot;M5&quot;) #Select just column with relevant information #When the files is generated from a SRC process, then parameter 3 (column 20) is DT Data_file &lt;- Data_file[,c(1:8,20)] #Change column names colnames(Data_file) &lt;- c(&#39;Device&#39;,&quot;Date&quot;,&#39;Hour&#39;,&#39;Plot&#39;,&#39;Record_number&#39;,&#39;CO2_ppm&#39;,&#39;P_mBa&#39;,&#39;Flow&#39;,&quot;DT&quot;) #remove row with NAs Data_file &lt;- drop_na(Data_file, Plot) #Give Date format to Date column Data_file$Date &lt;- as.Date(Data_file$Date, format = &quot;%d/%m/%Y&quot;) #DT is repeated some times #I create a new variable with difference between number record (seconds) Data_file &lt;- Data_file %&gt;% group_by(Plot) %&gt;% mutate(Seconds = Record_number-first(Record_number)) str(Data_file) ## grouped_df [3,392 × 10] (S3: grouped_df/tbl_df/tbl/data.frame) ## $ Device : chr [1:3392] &quot;M5&quot; &quot;M5&quot; &quot;M5&quot; &quot;M5&quot; ... ## $ Date : Date[1:3392], format: &quot;23-03-13&quot; &quot;23-03-13&quot; ... ## $ Hour : &#39;hms&#39; num [1:3392] 15:52:22 15:52:23 15:52:24 15:52:25 ... ## ..- attr(*, &quot;units&quot;)= chr &quot;secs&quot; ## $ Plot : num [1:3392] 1 1 1 1 1 1 1 1 1 1 ... ## $ Record_number: num [1:3392] 553 554 555 556 557 558 559 560 561 562 ... ## $ CO2_ppm : num [1:3392] 416 416 417 417 417 418 418 419 419 419 ... ## $ P_mBa : num [1:3392] 1000 1000 1000 1000 1000 ... ## $ Flow : num [1:3392] 342 343 344 343 343 343 343 343 344 344 ... ## $ DT : num [1:3392] 1 2 3 4 5 6 7 8 9 10 ... ## $ Seconds : num [1:3392] 0 1 2 3 4 5 6 7 8 9 ... ## - attr(*, &quot;groups&quot;)= tibble [18 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ Plot : num [1:18] 1 2 3 4 5 6 7 8 9 10 ... ## ..$ .rows: list&lt;int&gt; [1:18] ## .. ..$ : int [1:186] 1 2 3 4 5 6 7 8 9 10 ... ## .. ..$ : int [1:189] 187 188 189 190 191 192 193 194 195 196 ... ## .. ..$ : int [1:191] 376 377 378 379 380 381 382 383 384 385 ... ## .. ..$ : int [1:199] 567 568 569 570 571 572 573 574 575 576 ... ## .. ..$ : int [1:190] 766 767 768 769 770 771 772 773 774 775 ... ## .. ..$ : int [1:191] 956 957 958 959 960 961 962 963 964 965 ... ## .. ..$ : int [1:185] 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 ... ## .. ..$ : int [1:189] 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 ... ## .. ..$ : int [1:188] 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 ... ## .. ..$ : int [1:186] 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 ... ## .. ..$ : int [1:186] 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 ... ## .. ..$ : int [1:188] 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 ... ## .. ..$ : int [1:188] 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 ... ## .. ..$ : int [1:186] 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 ... ## .. ..$ : int [1:185] 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 ... ## .. ..$ : int [1:194] 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 ... ## .. ..$ : int [1:186] 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 ... ## .. ..$ : int [1:185] 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 ... ## .. ..@ ptype: int(0) ## ..- attr(*, &quot;.drop&quot;)= logi TRUE Ahora tiene mejor pinta: knitr::kable(Data_file[1:10,], booktabs = T, format = &quot;html&quot;) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;500px&quot;) Device Date Hour Plot Record_number CO2_ppm P_mBa Flow DT Seconds M5 23-03-13 15:52:22 1 553 416 1000.1 342 1 0 M5 23-03-13 15:52:23 1 554 416 1000.1 343 2 1 M5 23-03-13 15:52:24 1 555 417 1000.1 344 3 2 M5 23-03-13 15:52:25 1 556 417 1000.1 343 4 3 M5 23-03-13 15:52:26 1 557 417 1000.1 343 5 4 M5 23-03-13 15:52:27 1 558 418 1000.1 343 6 5 M5 23-03-13 15:52:28 1 559 418 1000.1 343 7 6 M5 23-03-13 15:52:29 1 560 419 1000.1 343 8 7 M5 23-03-13 15:52:30 1 561 419 1000.1 344 9 8 M5 23-03-13 15:52:31 1 562 419 1000.1 344 10 9 "],["visualizar-datos.html", "2 Visualizar datos", " 2 Visualizar datos Una vez que hemos seleccionado las columnas qu enos interesan del archivo y hemos dado un poco de forma a los datos, vamos a ver que pinta tienen nuestras gráficas. #Plot library(ggplot2) ggplot(Data_file, aes(x = DT, y = CO2_ppm))+ geom_point()+ facet_wrap(~Plot, scales = &#39;free&#39;) #Estaría interesante reducir el número de puntos de la siguiente forma: #Cuando hay varios valores iguales consecutivos, hacer la media del tiempo y usar un solo punto en mitad Bien, tienen bastante buena pinta pero quizźas se pueden limpiar un poco los datos. "],["limpiar-datos.html", "3 Limpiar datos", " 3 Limpiar datos En la gráfica anterior hemos visto los datos “en bruto” que ha registrado el IRGA. Sim embargo, tenemos muchos valores iguales consecutivos. Podemos hacer la media del tiempo y usar un solo punto. #I&#39;m going to reduce the number of points #when a cocnentration remains constante i&#39;m going to use just one point in the middle reduce_points &lt;- function(data){ data$rep &lt;- NA i &lt;- 1 for(p in 1:nrow(data)){ j &lt;- i+1 if(j &lt;= nrow(data)){ while (data$CO2_ppm[i] == data$CO2_ppm[j]) { data$rep[j-1]&lt;-i j &lt;- j+1 if(is.na(data$CO2_ppm[j])) break } data$rep[j-1]&lt;-i i &lt;- j } } result &lt;- data %&gt;% group_by(rep) %&gt;% summarise(across(where(is.numeric), ~mean(.)), across(Hour, ~seconds_to_period(mean(.))), across(Date, ~first(.))) return(result) } #Now, we apply the function Reduced_data &lt;- Data_file %&gt;% group_by(Plot) %&gt;% group_modify(~reduce_points(data=.x)) Por otro lado, vemos que el IRGA al final de algunos plots mete muchos de puntos que caen rápidamente. Para quitar esos artefacto vamos a eliminar las filas que vayan más allá del segundo 180 (o el tiempo que nosotros hayamos definido a la hora hacer las cámaras de respiración). #Remove rows beyond second 180 Reduced_data &lt;- Reduced_data %&gt;% filter(Seconds &lt;= 180) Vamos a ver cómo ha quedado: ggplot(Reduced_data, aes(x = DT, y = CO2_ppm))+ geom_point()+ facet_wrap(~Plot, scales = &#39;free&#39;) Una vez limpiados los datos, guardamos la tabla en un archivo por si necesitamos trabajar con ella más tarde. write_csv(Reduced_data, &quot;Data_cleaned.csv&quot;) "],["ajuste-lineal-para-obtener-pendientes.html", "4 Ajuste lineal para obtener pendientes", " 4 Ajuste lineal para obtener pendientes Para obtener las tasas (la pendiente) usamos un ajuste lineal. A parte del la pendiente, también nos interesa otra información como la R^2, el intervalo de confianza de la pendiente y si es significativa o no. Por ello, vamos a crear una función que ajuste una recta a nuestros datos y que además nos guarde toda la información que queremos en un objeto. #Una función para obtener la pendiente, la R y el intervalo de confianza fit_rates &lt;- function(data){ lm &lt;- lm(CO2_ppm~Seconds, data = data) cor &lt;- cor.test(formula = ~Seconds +CO2_ppm, data = data) ajustes &lt;- data.frame(R2 = as.numeric(cor$estimate^2), pvalue = cor$p.value, slope = as.numeric(lm$coefficients[2]), Intercept = as.numeric(lm$coefficients[1]), n = nrow(data), Conf_2.5 = confint(lm)[2,1], Conf_97.5 = confint(lm)[2,2]) return(ajustes) } Una vez creada la función, podemos aplicarla a nuestros datos: Results &lt;- Reduced_data %&gt;% group_by(Plot) %&gt;% group_modify(~fit_rates(data=.x)) Este es el objeto que hemos generado: knitr::kable(Results, booktabs = T, format = &quot;html&quot;) %&gt;% kableExtra::kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;500px&quot;) Plot R2 pvalue slope Intercept n Conf_2.5 Conf_97.5 1 0.9892470 0.0000000 0.1504342 418.0858 28 0.1441116 0.1567568 2 0.9891346 0.0000000 0.1654785 409.3472 30 0.1587647 0.1721924 3 0.9823930 0.0000000 0.0705262 414.6289 21 0.0659926 0.0750599 4 0.1330763 0.0729779 0.0052408 421.1234 25 -0.0005290 0.0110105 5 0.9867564 0.0000000 0.0566336 416.7878 14 0.0525069 0.0607603 6 0.9491739 0.0000000 0.0595649 416.8023 26 0.0537580 0.0653718 7 0.6470085 0.0000064 -0.0173003 399.9967 22 -0.0232606 -0.0113399 8 0.3929012 0.0017978 0.0129757 401.1265 22 0.0054524 0.0204990 9 0.2698004 0.0569679 -0.0102739 402.3065 14 -0.0209046 0.0003569 10 0.8259287 0.0000001 -0.0495195 402.2278 19 -0.0611524 -0.0378866 11 0.6760721 0.0000927 -0.0305813 403.0530 16 -0.0427152 -0.0184473 12 0.6588522 0.0001346 0.0138541 405.2474 16 0.0081397 0.0195686 13 0.4890403 0.0004191 -0.0141269 400.2419 21 -0.0210606 -0.0071932 14 0.4448686 0.0018130 -0.0125192 399.7605 19 -0.0196754 -0.0053631 15 0.8587568 0.0000000 0.0414192 403.0051 19 0.0328237 0.0500147 16 0.2483289 0.0417588 0.0074882 403.7539 17 0.0003184 0.0146580 17 0.9210936 0.0000000 0.0376358 403.8702 23 0.0326369 0.0426348 18 0.9544023 0.0000000 0.0689621 403.3326 22 0.0619312 0.0759929 Vamos a echar un vistazo a los ajustes que acabamos de realizar. #Now we can have a look into the plots with the fits ggplot(Reduced_data, aes(x = DT, y = CO2_ppm))+ geom_point()+ facet_wrap(~Plot, scales = &#39;free&#39;)+ geom_abline(data = Results, aes(intercept = Intercept, slope = slope), color = &quot;red&quot;)+ geom_text(data = Results, aes(x= 30, y = 410, label = paste(&quot;R2 =&quot;, round(R2, 2))), size = 2) Ahora vamos a guardar la información relativa a los ajsutes: write_csv(Results, &quot;Resultados_ajustes.csv&quot;) "],["calcular-la-tasa-de-emisión-o-absorción.html", "5 Calcular la tasa de emisión o absorción 5.1 ¿Pero no tenemos ya la pendiente? 5.2 ppm a mmol", " 5 Calcular la tasa de emisión o absorción 5.1 ¿Pero no tenemos ya la pendiente? Sí, en el apartado anterior hemos ajustado una ecuación lineal a nuestros datos y hemos obtenido una pendiente, con su intervalo de confianza y todo. Y, en efecto, esa pendiente también es una tasa. Sin embargo, la pendiente que hemos calculado nos da una tasa en ppm·segundos-1. Lo que a nosotros nos interesa es expresar la tasa en unas unidadeds comparable con otros trabajos, artículos, etc. Estos, generalmente, expresan la tasa de emisión de CO2 en mmol·m-2·día-1 o mg·m-2·día-1. 5.2 ppm a mmol Para esto vamos a basarnos en la conocida ley de los gases ideales que enuncia los siguiente: \\[\\begin{equation} PV = nRT \\tag{5.1} \\end{equation}\\] Donde, P es la presión que ejerce un gas, V es el volumen que ocupa dicho gas, n es el número de moles, R es la constante de los gases ideales y T es la temperatura expresada en grados Kelvin. La unidad de concentración que nos da el IRGA es ppm, partes por millón, en el caso de que la medida sea de una muestra de gas, esta indica el número de moles de nuestra sustancia (CO2) por millón de moles de aire, o lo que es lo mismo μmol/mol. Si fuera agua, serı́an los gramos de sustancia por millón de gramos del total (μg/g). Vamos a definir unos valores para este ejemplo. #definimos las condiciones V_camara &lt;- 1.171 #dm³ S &lt;- 0.78 #dm² Patm = 0.9905749 #atm #1003.7 #mBa Temp = 290.7 #Kelvin #17.7 #ºC R = 0.08205 #dm3·atm·mol-1·K-1 Slope = 0.5 #ppm/sec Imaginamos que tenemos una pendiente de 0.5 ppm/segundo. En primer lugar, para calcular el flujo debemos calcular cuantos moles de \\(CO_2\\) se han producido por segundo en nuestra cámara. Nuestra pendiente ahora mismo son ppm/seg, o lo que es lo mismo \\(\\mu\\)moles de CO2/ mol de aire / segundo. Por lo tanto, vamos a convertir los ppm (\\(\\mu\\)moles de CO2/ mol de aire) en \\(\\mu\\)moles de CO2. Tenemos una concentración y necesitamos una cantidad. Para ello, nos servimos de la ecuación (5.1) y de los datos que nos aporta el IRGA. Convertimos la presión atmosférica de mBa a atm (1 atm = 1013.25 mBa) y la temperatura ambiente, de 17.7 \\(^{\\circ} C\\), hay que convertirla en grados Kelvin. Por lo tanto, tenemos 0.9906 atm, una temperaturade 290.7 K y sabemos que 0.5 ppm son 0.0000005 moles de \\(CO_2\\) en 1 mol de aire. ¿Cuántos moles de aire tengo en mi cámara? Usando la ecuación (5.1): \\[\\begin{equation} n_{aire} = \\frac{1.019 ~atm \\cdot 1.171 ~dm^{3}}{0.08205 ~ dm^3 \\cdot atm \\cdot mol^{-1} \\cdot K^{-1} \\cdot 290.7 ~K} \\tag{5.2} \\end{equation}\\] #Calculamos los moles de aire n_aire &lt;- (Patm * V_camara) / (R * Temp) n_aire ## [1] 0.04863183 Ahora con una simple regla de tres podemos saber cuantos moles de CO2 se producen en mi cámara por segundo. \\[\\begin{equation} \\frac{0.5 ~\\mu mol~ CO_2}{1 ~mol~de~aire} = \\frac{x ~\\mu mol~ CO_2}{0.049 ~mol~de~aire} \\tag{5.3} \\end{equation}\\] umolCO2 &lt;- Slope*n_aire #umol de CO2 umolCO2 ## [1] 0.02431591 Pues ya sabemos los \\(\\mu\\)mol que se producen por segundo en mi cámara, 0.0243159 \\(\\mu\\) mol·s-1. Sabiendo la superficie de nuestra cámara y haciendo algunos cambios de unidades podemos calcular la tasa en mmol·m-2·día-1 o mg·m-2·día-1. tasa_mmol &lt;- umolCO2/1000*86400/S tasa_mmol ## [1] 2.693455 tasa_mg &lt;- umolCO2/1000*86400/S*44 tasa_mg ## [1] 118.512 ¡Pues listo! Ya hemos calculado la tasa de emisión y/o absorción de nuestro sedimento, suelo o masa de agua. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
